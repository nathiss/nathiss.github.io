[{"content":"Recently I\u0026rsquo;m investing a lot of time to developing a game server in Rust. I started with implementing network layer based on WebSockets. It\u0026rsquo;s far from being ready, but I developed a helper crate for creating detached, cancellable services.\nGame server backstory The idea of developing an authoritative game server always seemed appealing to me. Network programming, however, has many pitfalls:\nServer need to validate all use inputs to protect game state from bad actors. Ill-formed data sent by one client should not deny service for another player. Async programming is hard in general. So, in the past I have had many attempts to develop a game server. Each improving on mistakes made in the previous one.\nspectrum-old \u0026ndash; A real-time multiplayer browser game, Fusion-cpp \u0026ndash; This is the source code of the server for the Fusion game, [private repo], [private repo], [private repo]. And now I\u0026rsquo;m working on another. üëç\nThis time, improvements over the previous one are creating implementation that depend on traits and organizing TODOs to a single GitHub project.\nMaking Progressxkcd #1906\nCancellable crate Network functionalities in game servers (listeners, TCP streams, etc.) await for some input and usually yield a result.\nComponent Input Output Listener new incoming connection Client object TCP Stream data package parsed ClientMessage model Ping service timer tick new ping frame We can define a trait that will describe common interface for all of them:\n#[async_trait::async_trait] pub trait Cancellable { type Result; type Error; async fn run(\u0026amp;mut self) -\u0026gt; Result\u0026lt;CancellationResult\u0026lt;Self::Result\u0026gt;, Self::Error\u0026gt;; } Method run performs a single unit of work of the service. Internally it can await for the input to be available and then return its result. If the returned value is Err(Self::Error) then the service completes. If it succeeds, then it should return Ok(CancellationResult). CancellationResult is an enum defined as follows:\npub enum CancellationResult\u0026lt;T\u0026gt; { Item(T), Continue, Break, } impl\u0026lt;T\u0026gt; CancellationResult\u0026lt;T\u0026gt; { pub fn item(t: impl Into\u0026lt;T\u0026gt;) -\u0026gt; Self { Self::Item(t.into()) } } Enum\u0026rsquo;s variant control whether the service will continue to perform its work. If the service produces a value, then it should wrap it as CancellableResult::Item(t); it\u0026rsquo;s also a signal that the service should continue to work. If no value is available, but the service should continue then it returns CancellableResult::Continue (similar to Poll::Pending).\nIf the service finishes its work successfully (e.g. when the peer closes the connection) then the service should return CancellableResult::Break.\nCancellable trait has methods for spawning the service as a detached, background task:\n#[async_trait::async_trait] pub trait Cancellable { // ... async fn spawn(mut self, cancellation_token: CancellationToken) -\u0026gt; CancellableHandle\u0026lt;Self\u0026gt; { // ... } async fn spawn_with_callback\u0026lt;F\u0026gt;( mut self, cancellation_token: CancellationToken, mut callback: F, ) -\u0026gt; CancellableHandle\u0026lt;Self\u0026gt; where F: FnMut(Self::Result) -\u0026gt; Result\u0026lt;(), Self::Result\u0026gt; { // ... } } Both return a handle, which can be awaited for the service to complete, once it has been cancelled!\nIf the service produces results, then it can be spawned with spawn_with_callback, to consume them. If the callback returns Err(Self::Result) then the service completes immediately.\nThis setup offers a way of detaching services which perform work \u0026ldquo;on their own\u0026rdquo;, but sometimes services need to accept additional data. An example is TCP stream: it reads data packages from a peer and consumes them via callback. However, if the server decides the connection should be terminated, then the service should complete its work.\nEnter\u0026hellip;\nCommunicating with detached service When we spawn the service task we already get a handle:\nlet token = CancellableToken::new(); let handle = service.spawn(token.clone()).await; The handle can be used as an interface to send data to its service.\nhandle.update(ConnectionStatus::TerminatedByServer(reason)); The actual interface needs to be implementation-dependent \u0026ndash; defined in the Cancellable trait. By easily extending the trait we get:\n#[async_trait::async_trait] pub trait Cancellable { // ... type Handle; async fn new_handle(\u0026amp;mut self) -\u0026gt; Self::Handle; } When the service is spawned (either by spawn or spawn_with_callback), the method will call new_handle to construct the handle. The handle is owned by CancellableHandle, which implements Deref for Self::Handle type. With that setup, we can define a channel by which spawner can communicate with spawnee.\nI like the final product, so I\u0026rsquo;ve packaged it as a crate. It\u0026rsquo;s available on crates.io.\nüåä\n","permalink":"https://madebyme.today/articles/cancellable/","summary":"Recently I\u0026rsquo;m investing a lot of time to developing a game server in Rust. I started with implementing network layer based on WebSockets. It\u0026rsquo;s far from being ready, but I developed a helper crate for creating detached, cancellable services.\n","tag":"Open Source","title":"Cancellable"}]
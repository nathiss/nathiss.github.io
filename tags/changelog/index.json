[{"content":"Recently I was tasked with initialization of a new Python project. One of the requirements was to prepare a changelog. I liked the idea, but my gut feeling was that the future project contributors won\u0026rsquo;t keep the changelog always up-to-date and it\u0026rsquo;s quality will decline over time. This article proposes a feature which enforces changelog updates, when it\u0026rsquo;s required to do so.\nWhat\u0026rsquo;s a changelog A changelog is a log or record of all notable changes made to a project. The project is often a website or software project, and the changelog usually includes records of changes such as bug fixes, new features, etc.\nfrom Wikipedia.\nThe phrase \u0026ldquo;notable changes\u0026rdquo; is the key here. Not all changes to the project are required to have an entry in its changelog: workflow updates, typo fixes in README, SonarQube settings; they all are transparent to the Python package produced by the project.\nLet\u0026rsquo;s take a look at an example:\n. ├─ .github │ └─ workflows │ └── workflow.yaml ├─ docs │ ├─ conf.py │ ├─ index.rst │ └─ Makefile ├─ foo │ ├─ __init__.py │ └─ bar │ ├─ __init__.py │ └─ baz.py ├─ tests │ ├─ __init__.py │ └─ test_bar.py ├─ .gitignore ├─ README.md ├─ Makefile ├─ setup.py ├─ Manifest.in ├─ pyproject.toml └─ Changelog.md This is a pretty standard (and also minimalistic!) take on a Python project. The pipeline defined in .github/workflows/workflow.yaml builds, tests and publishes the package. Initially project stored its version in pyproject.toml, while Changelog.md contained human-readable lists of additions, fixes, and improvements for each release. Having a standard usually makes things easier, so we adopted keep a changelog, which also uses Semantic Versioning 2.0.0, so that was nice.\nKeep a changelog is just a Markdown template \u0026ndash; it has no associated toolset. Here\u0026rsquo;s an example of a changelog with two entries:\n# Changelog All notable changes to this project will be documented in this file. The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/), and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html). ## [1.2.0] - 2023-10-01 ### Added - Support for Python 3.12. - Utility for parsing `foo`. ### Fixed - Worker subprocesses are now correctly closed. ### Changed - Update `pylint` version to `~= 2.17`. ## [1.1.2] - 2019-02-15 ### Fixed - Typo in project\u0026#39;s title in docs. Keep(ing) a changelog up-to-date When releasing a new package version one needs to remember to update the version in two places: pyproject.toml and Changelog.md. Also, there\u0026rsquo;s no mechanism to enforce that behavior; we could create a workflow step to validate that both places are in sync, but relaying on CI to inform contributors about the necessary changes seems far from ideal.\nInstead, we made Changelog.md the only place where the version can be updated. pyproject.toml expects the version to be statically defined; we can disable that behavior by marking the version as dynamic.\n[build-system] requires = [\u0026#34;setuptools\u0026#34;, \u0026#34;wheel\u0026#34;] build-backend = \u0026#34;setuptools.build_meta\u0026#34; [project] name = \u0026#34;foo\u0026#34; readme = \u0026#34;README.md\u0026#34; requires-python = \u0026#34;\u0026gt;=3.9\u0026#34; dependencies = [ \u0026#34;requests\u0026#34;, ] dynamic = [\u0026#34;version\u0026#34;] # \u0026lt;---- The version still needs to be defined somewhere, and using setup.py for that purpose gives us an advantage \u0026ndash; we can execute an arbitrary Python code there.\nimport re from pathlib import Path from typing import Generator from setuptools import setup def __get_versions() -\u0026gt; Generator[tuple[int, int, int], None, None]: dir_name = Path(__file__).parent with open(dir_name / \u0026#34;Changelog.md\u0026#34;, \u0026#34;r\u0026#34;) as file: lines = file.readlines() for line in lines: m = re.match(r\u0026#34;^##\\s+\\[(\\d+\\.\\d+\\.\\d+)\\]\u0026#34;, line) if m: x, y, z = m.group(1).split(\u0026#34;.\u0026#34;, 2) yield int(x), int(y), int(z) def __get_highest_version() -\u0026gt; str: highest_version = max(__get_versions()) return \u0026#34;.\u0026#34;.join(map(str, highest_version)) setup( version=__get_highest_version(), ) Now the only place where package\u0026rsquo;s version needs to be updated is the changelog itself. Note that this change does not enforce updating the changelog for every change. However, to release a new version of the package one is required to add a new changelog entry.\nNow, since the presence of Changelog.md is necessary for the build to succeed, we should inform the build system about this dependency. MANIFEST.in contains include/exclude patters for non-standard files (see official docs). Add the following line to the manifest:\n# ... include Changelog.md Accessing project version from Sphinx Sphinx is a most popular tool for generating documentation out of Python source files. It keeps its configuration in the conf.py file, which has two special attributes related to the project\u0026rsquo;s version:\nversion \u0026ndash; the major project version (see official documentation), release \u0026ndash; the full project version (see official documentation). With the current setup it\u0026rsquo;s hard for Sphinx to read the version, since it\u0026rsquo;s only accessible from setup.py. The easiest workaround is to extract the parsing to an external module and then use that module as a dependency in both conf.py and setup.py.\n# version.py import re from pathlib import Path from typing import Generator from setuptools import setup def __get_versions() -\u0026gt; Generator[tuple[int, int, int], None, None]: dir_name = Path(__file__).parent with open(dir_name / \u0026#34;Changelog.md\u0026#34;, \u0026#34;r\u0026#34;) as file: lines = file.readlines() for line in lines: m = re.match(r\u0026#34;^##\\s+\\[(\\d+\\.\\d+\\.\\d+)\\]\u0026#34;, line) if m: x, y, z = m.group(1).split(\u0026#34;.\u0026#34;, 2) yield int(x), int(y), int(z) def __get_highest_version() -\u0026gt; str: highest_version = max(__get_versions()) return \u0026#34;.\u0026#34;.join(map(str, highest_version)) version = __get_highest_version() After that we can import the module in setup.py:\nfrom setuptools import setup from version import version setup( version=__get_highest_version(), ) \u0026hellip; and conf.py:\nimport sys from pathlib import Path project = \u0026#34;foo\u0026#34; copyright = \u0026#34;2023\u0026#34; author = \u0026#34;Kamil Rusin\u0026#34; root_dir = Path(__file__).parents[1] sys.path.insert(0, str(root_dir)) from version import version as __project_version version = __project_version release = version Again, we cannot forget about informing the build system about the new dependency in MANIFEST.in:\n# ... include Changelog.md include version.py Afterthought Maintaining a changelog can make a project easier to understand. Hopefully, with the changes proposed in this article you\u0026rsquo;ll find changelogs more manageable. This feature does not enforce changelog updates from the contributors \u0026ndash; they will only need to do so, when they want to release a new version of the package.\nI highly encourage to always release a new version even for the smallest change in the project sources that is observable for the users. Whether it\u0026rsquo;s worth to add changelog entries for project\u0026rsquo;s meta updates, is up to you.\nPhoto by Jasper Garratt on Unsplash\n","permalink":"https://madebyme.today/articles/keep-a-changelog/","summary":"Recently I was tasked with initialization of a new Python project. One of the requirements was to prepare a changelog. I liked the idea, but my gut feeling was that the future project contributors won\u0026rsquo;t keep the changelog always up-to-date and it\u0026rsquo;s quality will decline over time. This article proposes a feature which enforces changelog updates, when it\u0026rsquo;s required to do so.\n","tag":"Changelog","title":"Keep a Changelog"}]